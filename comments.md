Для повышения читабельности кода в InfoMessage можно использовать декоратор @dataclass, тогда мы избежим, как минимум, большого init) подробнее здесь https://docs.python.org/3/library/dataclasses.html

Можно еще лучше:
1. Выносим все фразы в константу (например, MESSAGE) на уровень класса
2. А в методе get_message используем asdict https://docs.python.org/3/library/dataclasses.html#dataclasses.asdict и элегантно передаем данные в .format)
asdict преобразует данные в словарь, поэтому нужно будет посмотреть распаковку словарей в питоне - синтаксис очень похож на распаковку списков/кортежей

Думаю, нет необходимости выносить все в отдельные переменные.
Если у нас добавятся новые строки или наоборот нужно будет что-то убрать, то такая конструкция только усложнит перечисленные задачи
Читабельность кода при этом не пострадает)

Думаю, нет необходимости разносить строки в такую конструкцию.
Если у нас добавятся новые строки или наоборот нужно будет что-то убрать, то такая конструкция только усложнит перечисленные задачи
Можно сделать что-то вроде
return (f'...'
           f'...'
           ....
               )
Читабельность кода при этом не пострадает и даже улучшится)

Здесь и ниже: pass нам нужен когда мы хотим, чтобы функция/метод в каком-то случае ничего не делали https://pythonz.net/references/named/pass/
В нашем случае в init у нас имеются инструкции и в объявлении pass после них нет необходимости

Константы выносим на уровень класса в самое начало, после объявления класса/докстрингов https://www.python.org/dev/peps/pep-0008/#constants

Коэффициент для перевода часов в минуты используется в каждом классе-наследнике, поэтому его лучше вынести в базовый класс

Здесь и в остальных классах: правильно, что коэффициенты вынесены на уровень класса.
Но в нашем случае коэффициенты являются константами, поэтому обозначить их лучше заглавными буквами https://www.python.org/dev/peps/pep-0008/#constants
Также не забываем проаннотировать их тип)

Вместо pass лучше поднять NotImplementedError, тогда мы получим понятную для пользователя/разработчика ошибку, если забудем переопределить в дочерних классах метод get_spent_calories()

Отлично! Правильное использование self.class.name для возврата имени класса

Здесь нам нужно вернуть только имя класса, а мы возвращаем целый self. И, чтобы вернуть только имя класса, нам приходится в каждом дочернем методе пользоваться магическим методом str https://habr.com/ru/post/186608/
Если мы забудем в каком-то классе-наследнике прописать str, то нам вернется не имя класса и мы получим ошибку https://pythonz.net/references/named/self/
Мы можем вернуть только имя класса и без str: https://stackoverflow.com/questions/510972/getting-the-class-name-of-an-instance?rq=1

Здесь и ниже: количество минут в часе можно вынести в константу на уровне базового класса, иначе мы получаем магическое число https://ru.wikipedia.org/wiki/Магическое_число_(программирование)

Здесь data это составная структура данных, т.е. список каких-то чисел, поэтому используем полную аннотацию 
Более наглядно https://www.python.org/dev/peps/pep-0484/#id23

Несколько комментариев, позволяющих лучше понять, что происходит в коде - это хорошо.
Но когда комментариев становится слишком много читать код становится сложнее. Нужен баланс)
Предлагаю немного почистить комментарии, тем более здесь у нас есть докстринг)


Словарь в нашем случае - это правильно и хорошо.
Но с ним нужно немного поработать:
1. Название переменной должно быть осмысленным, описываем в названии, что мы туда положили. При этом желательно не использовать в качестве названий переменных отсылки к типам данных (вроде _dict)
2. Используем hanging-indent https://stackoverflow.com/questions/22849746/pep8-hanging-indent-specification, т.е. разносим каждую запись на разные строки. Так будет легче читать код и добавлять в него новые записи.
3. Желательно проаннотировать словарь. Ключом у нас является строка, а значением - тип базового класса. Для аннотации значений поможет Type из модуля Typing https://digitology.tech/docs/python_3/library/typing.html#typing.Type
4. Что произойдет, если пользователь передаст тип тренировки, отсутствующий в нашем словаре? Он получит ошибку, которая будет для него не понятна. Для этого мы заранее обработаем такую ошибку (и, возможно, какие либо еще..) и выведем человекочитаемое сообщение об отсутствии такого типа тренировки. Можно воспользоваться проверкой наличия ключа в словаре или блоком try/except.
Проверка наличия ключа в словаре тут https://stackoverflow.com/questions/1602934/check-if-a-given-key-already-exists-in-a-dictionary
Try/except тут https://docs.python.org/3/tutorial/errors.html#handling-exceptions


Аннотация словаря это отлично.
Но в качестве значений здесь мы передаем не Any, а вполне конкретный тип данных.
В модуле typing есть Type, в который мы можем передать название нашего базового класса в виде Type[...]. 
Немного информации - https://digitology.tech/docs/python_3/library/typing.html#typing.Type
И в названии переменных стараемся не пользоваться типами данных, вроде var_list, var_tuple, etc.


С большим количеством if-ов есть проблема, стоит появиться новому типу тренировки, как приходится писать новое условие. А если таких типов станет очень много, то будет совсем сложно - как читать такой код, так и править его.
Чтобы не обращаться по имени каждого типа тренировки нам помогает словарь: обращаемся по ключу, получаем необходимый класс. Кстати, тут нужно учесть, что нам может прийти неверный тип тренировки, например: в таком случае проверим есть ли ключ в словаре, если нет, то выведем пользователю понятное сообщение о том, что такого типа тренировки у нас нет) Или же можем воспользоваться блоком try/except.
Проверка наличия ключа в словаре тут https://stackoverflow.com/questions/1602934/check-if-a-given-key-already-exists-in-a-dictionary
Try/except тут https://docs.python.org/3/tutorial/errors.html#handling-exceptions
Осталось понять, как быть с тем, что для инициализации разных классов требуется разное количество переменных. Для этого есть такой инструмент, как распаковка , наглядно - https://www.kite.com/python/answers/how-to-unpack-a-list-in-python
И тогда мы избавимся от большого количества ифов и обработаем возможные ошибки)


Решение действующее, но здесь желательно обойтись без if-ов.
Дело в том, что количество разных видов тренировок может сильно вырасти, и будет трудозатратно как прописывать каждый случай в конструкцию if, так и убирать его. 
Т.е. трудности возникнут как с чтением, так и с записью, да и как гласит дзен питона - "Плоское лучше, чем вложенное" https://www.python.org/dev/peps/pep-0020/ )
В данном случае можно будет воспользоваться словарем, который про проаннотируем, где ключи - тип тренировки (намек как аннотировать такой тип - https://digitology.tech/docs/python_3/library/typing.html#typing.Type), а значения - классы. 
Т.е. идея такая: нам приходит тип тренировки, мы ищем такой ключ в словаре и по ключу находим класс для этой тренировки.
Так будет лаконично, просто для чтения/записи и, скорее всего, мы сможем избежать каких-либо ошибок.
Отмечу, что после того, как здесь появится словарь, нужно будет подумать насчет обработки ошибок - например, если нам придет неизвестный тип тренировки. Можно будет посмотреть в сторону try/except или проверки наличия ключа в словаре 
Проверка наличия ключа в словаре тут https://stackoverflow.com/questions/1602934/check-if-a-given-key-already-exists-in-a-dictionary
Try/except тут https://docs.python.org/3/tutorial/errors.html#handling-exceptions
А после обработки вывести человекочитаемую строку об ошибке.


Привет, меня зовут Ольга, я действующий python-разработчик и Ваш ревьюер :) поздравляю с выполнением первого задания! Если возникнут какие-либо вопросы по ревью, можно обращаться ко мне в слак.
Небольшой итог ревью: 
Удачи!

Для соблюдения код-стайла (чтобы не делать это вручную), среды разработки, как правило, предоставляют удобные настройки, например форматирование при сохранении, подробнее: 1. VS Code - https://code.visualstudio.com/updates/v1_6#_format-on-save 2. PyCharm - https://www.jetbrains.com/help/pycharm/reformat-and-rearrange-code.html#exclude_file_from_reformat